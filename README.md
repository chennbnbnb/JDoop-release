Technical principles and introduction please see [JDoop_detailed_introduction](./JDoop_detailed_introduction/README.md)

This tool is under development, so it may not be that easy to use, please forgive me.

## 1. Install
0. Environment
    - java8
    - python3.*
    - The system recommends using ubuntu
    - Memory: more than 32G
    - Disk: free space more than 50G
    - CPU: more than 8 cores

1. Install dependencies
```shell
sudo apt-get install \
    libsqlite3-dev \
    zlib1g-dev
```

2. Then check if there are any uninstalled dependencies
```shell
ldd ./solver
```

The solver is a binary executable file compiled with Datalog. The normal situation should be as follows. If there is a dynamic link library that cannot be found, you can install it yourself.
```
        libsqlite3.so.0 => /usr/lib/x86_64-linux-gnu/libsqlite3.so.0 (0x00007f4d7c4d7000)
        libz.so.1 => /usr/lib/x86_64-linux-gnu/libz.so.1 (0x00007f4d7c4ba000)
        libstdc++.so.6 => /usr/lib/x86_64-linux-gnu/libstdc++.so.6 (0x00007f4d7c2ed000)
        libgomp.so.1 => /usr/lib/x86_64-linux-gnu/libgomp.so.1 (0x00007f4d7c2ad000)
        libgcc_s.so.1 => /usr/lib/x86_64-linux-gnu/libgcc_s.so.1 (0x00007f4d7c293000)
        libpthread.so.0 => /usr/lib/x86_64-linux-gnu/libpthread.so.0 (0x00007f4d7c271000)
        libc.so.6 => /usr/lib/x86_64-linux-gnu/libc.so.6 (0x00007f4d7c09a000)
        libm.so.6 => /lib/x86_64-linux-gnu/libm.so.6 (0x00007f4d7bf4e000)
        libdl.so.2 => /lib/x86_64-linux-gnu/libdl.so.2 (0x00007f4d7bf48000)
        /lib64/ld-linux-x86-64.so.2 (0x00007f4d7d41e000)
```

3. Execute `./solver --version`, the output should be as follows
```
====================================================================
 Datalog Program: /home/user/doop-mirror/out/release/gen_6272271873373902997.dl
 Usage: ./solver [OPTION]

 Options:
    -D <DIR>, --output=<DIR>     -- Specify directory for output relations
                                    (default: )
                                    (suppress output with "")
    -F <DIR>, --facts=<DIR>      -- Specify directory for fact files
                                    (default: )
    -j <NUM>, --jobs=<NUM>       -- Specify number of threads
                                    (default: 24)
    -h                           -- prints this help page.
--------------------------------------------------------------------
 Version: 2.4
 Word size: 64 bits
--------------------------------------------------------------------
 Copyright (c) 2016-22 The Souffle Developers.
 Copyright (c) 2013-16 Oracle and/or its affiliates.
 All rights reserved.
====================================================================
```

## 2. Usage

### 2.1 Analyze servlet projects
`test_cases/servlet_test` is a simple servlet project sample, which contains a simple command execution vulnerability sample.

`test_cases/servlet_test/target/JavaWebLearn-1.0-SNAPSHOT.war` is the war generated by this sample. Run the following command to perform taint analysis on the war package.

```shell
python3 main.py ./test_cases/servlet_test/target/JavaWebLearn-1.0-SNAPSHOT.war
```

The results of taint flow analysis are as follows, indicating that the data from the entry class `com.example.HelloServlet` will be propagated to `java.lang.Runtime.exec()`
```
[servlet_input=>cmdi]: 
        Source: <com.example.HelloServlet: void doPost(jakarta.servlet.http.HttpServletRequest,jakarta.servlet.http.HttpServletResponse)>/@parameter0
        Invocation to sink method: <com.example.HelloServlet: void doPost(jakarta.servlet.http.HttpServletRequest,jakarta.servlet.http.HttpServletResponse)>/java.lang.Runtime.exec/0
        Sink argument: <com.example.HelloServlet: void doPost(jakarta.servlet.http.HttpServletRequest,jakarta.servlet.http.HttpServletResponse)>/$stack8
```

### 2.2 Analysis Spring Framework project

`test_cases/jeecg-system-start-3.5.3.jar` is a package in spring-boot-fat-jar format packed by `spring-boot-maven-plugin`. This package comes from the open source project [jeecg] (https://github.com/jeecgboot/jeecg-boot), a template injection vulnerability [CVE-2023-4450](https://nvd.nist.gov/vuln/detail/CVE-2023-4450) existed in this project. The commit corresponding to this test package is `0518175`.

Run the following command to analyze the package
```shell
python3 main.py ./test_cases/jeecg-system-start-3.5.3.jar
```
An exception may occur when soot decompiles some methods. This exception will not affect the normal analysis process and can be ignored.

The analysis will be completed after 3 to 5 minutes, and the results are as follows. The first two taint flows leaked by template injection actually exist and can be used; the third taint flow injected by SQL also really exists, but the input SQL in jeecg The data has been filtered and therefore cannot be used. 
```
[spring entry method param=>Freemarker SSTI Inject]: 
	Source: <org.jeecg.modules.jmreport.desreport.a.a: org.jeecg.modules.jmreport.common.vo.Result b(com.alibaba.fastjson.JSONObject)>/@parameter0
	Invocation to sink method: <org.jeecg.modules.jmreport.desreport.render.utils.FreeMarkerUtils: java.lang.String a(java.lang.String,java.util.Map)>/freemarker.template.Template.<init>/0
	Sink argument: <org.jeecg.modules.jmreport.desreport.render.utils.FreeMarkerUtils: java.lang.String a(java.lang.String,java.util.Map)>/$u5

[spring entry method param=>Freemarker SSTI Inject]: 
	Source: <org.jeecg.modules.jmreport.desreport.a.a: org.jeecg.modules.jmreport.common.vo.Result c(com.alibaba.fastjson.JSONObject)>/@parameter0
	Invocation to sink method: <org.jeecg.modules.jmreport.desreport.render.utils.FreeMarkerUtils: java.lang.String a(java.lang.String,java.util.Map)>/freemarker.template.Template.<init>/0
	Sink argument: <org.jeecg.modules.jmreport.desreport.render.utils.FreeMarkerUtils: java.lang.String a(java.lang.String,java.util.Map)>/$u5

[spring entry method param=>sqli]: 
	Source: <org.jeecg.modules.online.cgreport.a.b: org.jeecg.common.api.vo.Result a(java.lang.String,java.lang.String)>/@parameter0
	Invocation to sink method: <org.jeecg.common.util.dynamic.db.DynamicDBUtil: java.util.List findList(java.lang.String,java.lang.String,java.lang.Object[])>/org.springframework.jdbc.core.JdbcTemplate.queryForList/0
	Sink argument: <org.jeecg.common.util.dynamic.db.DynamicDBUtil: java.util.List findList(java.lang.String,java.lang.String,java.lang.Object[])>/sql#_0
```

### 2.3 Output taint flow graph

All analysis is performed on jimple, which is the intermediate representation after bytecode decompilation. Therefore, the taint flow graph represents the flow of tainted objects on jimple, which is essentially a pointer flow graph.

To make things sample, taking `test_cases/servlet_test` as an example, the jimple decompiled from the bytecode is saved in the `last-analysis/database/jimple` directory

For example, the jimple corresponding to the `com.example.HelloServlet` class is located in `last-analysis/database/jimple/com/example/HelloServlet.shimple`, as follows (*Note: shimple is a variant of jimple, for details, please refer to soot IR format in *)

Jimple is similar to the java source code. It is necessary to explain the command format of the variables.
   -  `@this, @parameter0, ...`: Variables starting with \@ are special variables. These variables have special meanings and are automatically generated by soot.
   - `$stack14, $stack15, ...`: Variables starting with \$ are temporary variables, which are automatically created by soot when generating IR. The definition cannot be found in the source code.
   - `param#_34, foundit#_35`: This is an ordinary variable, which corresponds to the variables in the source code one-to-one. The naming format is `variable name#_declaration line number`

The following is the Jimple representation corresponding to the `HelloServlet::doPost()` method
```java
public class com.example.HelloServlet extends jakarta.servlet.http.HttpServlet
{
    ...

    public void doPost(jakarta.servlet.http.HttpServletRequest, jakarta.servlet.http.HttpServletResponse) throws jakarta.servlet.ServletException, java.io.IOException
    {
        java.io.PrintStream $stack11;
        jakarta.servlet.http.HttpServletRequest request#_0;
        java.lang.Process $stack10;
        java.lang.Runtime $stack9;
        java.lang.String[] $stack8;
        java.io.IOException $stack13;
        com.example.HelloServlet this#_0;
        java.lang.String $stack7, $stack12;
        jakarta.servlet.http.HttpServletResponse response#_0;

        this#_0 := @this: com.example.HelloServlet;

        request#_0 := @parameter0: jakarta.servlet.http.HttpServletRequest;

        response#_0 := @parameter1: jakarta.servlet.http.HttpServletResponse;

        $stack7 = interfaceinvoke request#_0.<jakarta.servlet.http.HttpServletRequest: java.lang.String getParameter(java.lang.String)>("123");

        $stack8 = newarray (java.lang.String)[2];

        $stack8[0] = "echo";

        $stack8[1] = $stack7;

        $stack9 = staticinvoke <java.lang.Runtime: java.lang.Runtime getRuntime()>();

     label1:
        $stack10 = virtualinvoke $stack9.<java.lang.Runtime: java.lang.Process exec(java.lang.String[],java.lang.String[],java.io.File)>($stack8, null, null);

        ...
    }
}
```
`last-analysis/result/TaintObjectPropagateEdge.csv` records every propagation edge of all tainted objects

Running this script `showTaintFlow.py` will output the propagation paths of all taint flows in `last-analysis/result/LeakingTaintedInformation.csv`
```shell
python3 showTaintFlow.py
```

`showTaintFlow.py` will automatically read the taint flow analysis results and use the DFS algorithm to search on the taint propagation graph to find the complete taint propagation path from Source to Sink.
```
taint flow: [servlet_input] ==> [cmdi]
        Source[<com.example.HelloServlet: void doPost(jakarta.servlet.http.HttpServletRequest,jakarta.servlet.http.HttpServletResponse)>/@parameter0]
                |
                | Call source method
                V
        <MOCK HttpServletRequest for [<com.example.HelloServlet: void doPost(jakarta.servlet.http.HttpServletRequest,jakarta.servlet.http.HttpServletResponse)>/@parameter0]>|<com.jd.lab.jakarta.MockHttpServletRequest: java.lang.String sourceStr>
                |
                | Instance field load
                V
        <com.jd.lab.jakarta.MockHttpServletRequest: java.lang.String getParameter(java.lang.String)>/$stack2
                |
                | CallEdge: return value
                V
        <com.example.HelloServlet: void doPost(jakarta.servlet.http.HttpServletRequest,jakarta.servlet.http.HttpServletResponse)>/$stack7
                |
                | Sink: String=>String[]
                V
        sink method invocation[<com.example.HelloServlet: void doPost(jakarta.servlet.http.HttpServletRequest,jakarta.servlet.http.HttpServletResponse)>/java.lang.Runtime.exec/0], argument: [<com.example.HelloServlet: void doPost(jakarta.servlet.http.HttpServletRequest,jakarta.servlet.http.HttpServletResponse)>/$stack8]
```

If there are many taint streams in `LeakingTaintedInformation.csv` and you only want to see the taint propagation graph of a certain source point, you can use **Source** as a parameter. The sample command is as follows
```shell
python3 showTaintFlow.py --source "<com.example.HelloServlet: void doPost(jakarta.servlet.http.HttpServletRequest,jakarta.servlet.http.HttpServletResponse)>/@parameter0"
```


### 2.4 JSON data format description
After analysis, call `python3 showTaintFlow.py --json ./res.json` to write the analysis results into the `res.json` file in JSON format. The example is as follows
```json
[   
    {
        "source_label": "spring entry method param",
        "source": "<org.jeecg.modules.drag.b.d: org.jeecg.common.api.vo.Result a(org.jeecg.modules.drag.vo.DynamicDataSourceVo)>/@parameter0",
        "sink_label": "JDBC deserial",
        "sink_param_ctx_id": 187,
        "sink_param": "<org.jeecg.modules.drag.b.d: org.jeecg.common.api.vo.Result a(org.jeecg.modules.drag.vo.DynamicDataSourceVo)>/$stack29",
        "sink_invo": "<org.jeecg.modules.drag.b.d: org.jeecg.common.api.vo.Result a(org.jeecg.modules.drag.vo.DynamicDataSourceVo)>/java.sql.DriverManager.getConnection/0",
        "path": [
            {
                "idx": 0,
                "to": "<pojo for param <org.jeecg.modules.drag.b.d: org.jeecg.common.api.vo.Result a(org.jeecg.modules.drag.vo.DynamicDataSourceVo)>/@parameter0>|<org.jeecg.modules.drag.vo.DynamicDataSourceVo: java.lang.String dbUrl>",
                "remark": "Spring entry method param"
            },
            {
                "idx": 1,
                "to": "<org.jeecg.modules.drag.vo.DynamicDataSourceVo: java.lang.String getDbUrl()>/$stack1",
                "remark": "Instance field load"
            },
            ....
            {
                "idx": 7,
                "to": "<org.jeecg.modules.drag.b.d: org.jeecg.common.api.vo.Result a(org.jeecg.modules.drag.vo.DynamicDataSourceVo)>/$stack29",
                "remark": "CallEdge: return value"
            }
        ]
    },
    ....
]
```
Field meaning
   - `source_label`: a label indicating the type of taint source
   - `source`: Indicates the taint source, usually a parameter of the entry class, which is **the starting point of the taint flow**
   - `sink_label`: A label indicating the type of sink method
   - `sink_param_ctx_id`: The context ID of the parameters for calling the sink method. If the path for calling the sink method is different, the context ID of the calling parameters will also be different. You don’t need to pay attention to it.
   - `sink_param`: The parameters for calling the sink method are also the end point of the taint stream.
   - `sink_invo`: Statement that calls the sink method
   - `path`: The taint flow propagation path from `source` to `sink_param`, where each element is a propagation edge
     - `idx`: Serial number, the starting point of edge `idx` is the end point of edge `idx-1`
     - `to`: The tainted object is propagated to this node
     - `remark`: Remarks on the propagation edge, indicating the reason for propagation

## 3. Project structure

This project contains the following files
```
.
├── fact_generators                             
│   ├── config_generator                        // Generate facts based on configuration files
│   │   ├── main.py
│   │   ├── properties.py
│   │   └── SPI.py
│   └── soot-fact-generator.jar                 // Generate facts based on bytecode
│
├── last-analysis                               // Save analysis results
│   ├── database/                               // All generated facts
│   └── result/                                 // analysis results
├── main.py                                     // Assistant script
├── mocked_jars                                 // Customized jar package for static analysis
│   ├── jdk                                     // mocked JDK
│   │   ├── jce.jar
│   │   ├── jsse.jar
│   │   ├── nashorn.jar
│   │   └── rt.jar
│   └── servlet                                 // mocked JDK
│       ├── jakarta.servlet-api-5.0.0.jar
│       ├── javax.servlet-api-4.0.1.jar
│       └── MockServlet-1.0-SNAPSHOT.jar
│
├── sink_rules                                  //  rules to define sink method
│   ├── migrated_rules          
│   │   ├── LeakingSinkMethodNameArg.tsv
│   │   ├── LeakingSinkMethodNameVarArg.tsv       
│   └── primitive_rules                         
│       └── LeakingSinkMethodArg.tsv
│
├── README.md
├── showTaintFlow.py                            // Script used to output taint propagation flow graph
├── solver                                      // Binary executable file obtained by using souffle to compile datalog rules
└── test_cases                             
    ├── jeecg-system-start-3.5.3.jar            // jeecg cms
    └── servlet_test                            // servlet test war
        ├── pom.xml
        ├── src/
        └── target
            └── JavaWebLearn-1.0-SNAPSHOT.war
```

The processing flow of `soot-fact-generator.jar` is
   1. Disassemble the input war package
   2. Translate bytecode to IR
   3. Perform in-process optimizations such as constant propagation and dead zone code elimination for IR
   4. Extract the facts file from the generated IR

The solver `solver` will then solve the extracted facts according to the static analysis rules.

`main.py` is an assistant script, responsible for stringing together the entire process and processing the calling parameters to simplify use.

## 4. Ability

### 4.1 False positives caused by streams insensitivity and indexes insensitivity

This project uses a static analysis algorithm that is stream-insensitive and index-insensitive, which will lead to two unavoidable false positives.

Stream insensitivity means that the execution order of the two executions will not be distinguished. Therefore, static analysis considers the following two programs to be equivalent and believes that they both have a tainted stream of `source()=>sink()`, which leads to false positives.

```java
// True Positive
String str;
sink(str);
str = source();

// False Positive
String str;
sink(str);
str = source();
```

Index insensitivity means that for data types such as arrays, sets, and Maps, their indexes will not be distinguished. Therefore, the following two programs are equivalent during static analysis.
```java
// True Positive
String[] arr = new String[2];
arr[0] = source();
sink(arr[0])

// False Positive
String[] arr = new String[2];
arr[0] = source();
sink(arr[1])
```

### 4.2 Spring framework adaptation

The Spring framework is relatively complex and currently only handles commonly used annotation-based configuration methods, as follows:
- Support jar packages generated by `spring-boot-maven-plugin`
- Spring Bean: Classes annotated with `Component, Service, Repository, Controller, ControllerAdvice, RestController, RestControllerAdvice` will be recognized as Bean
- Entry point: All methods annotated with `RequestMapping` in the control class will be regarded as the entry methods for processing HTTP requests, and the analysis will start from these entry methods.
- Source Definition: 
    - Parameters of type `String, String[], char[], char` in the entry method are taint sources.
    - For parameters of container types such as `Map<String, String>, List<List>, Set<String>` in the entry method, container objects will be created for them and taint objects will be added.
    - The parameters of the entry method are Pojo types, which will recursively create objects for the internal fields of Pojo and add taint objects. 
    - For the parameter of type `JSONObject` in the entry method, `json.getString()` is considered a taint source
- Support the following three dependency injection methods of the Spring framework. Find corresponding components based on type
    - `@Autowired`/`@Resouce` on field
    - `@Autowired`/`@Resouce` on parameter of constructor 
    - `@Autowired`/`@Resouce` on parameter of setter method 


### 4.3 json deserialization support

Currently only jackson 1.\* and jackson2.\* deserialization is supported.

For the following code, if `jsonStr` is a tainted string, the key and value inside the created `map` object point to the tainted string.

```java
String jsonStr
ObjectMapper objectMapper = new ObjectMapper();
Map<String, String> map = (Map)objectMapper.readValue(jsonStr, HashMap.class);
```

Currently, it is supported to deserialize the following types of objects:
1. `String`, `char`
1. `String` / `char` array of any dimension, such as `String[][][]`
2. `Map<String, String>` and its derived classes
3. `List<String>` and its derived classes
4. `Set<String>` and its derived classes

### 4.4 support to maven-assembly-plugin

If the following two conditions are met, the input package is considered to be a package generated by the `maven-assembly-plugin` plug-in.
1. The suffix of the input file is `.zip`
2. The compressed package contains the `lib` directory

The processing rules are as follows:
1. Treat all jar packages in the `/lib` directory as jar packages of dependent components
2. Treat other compressed jar packages as application jar packages



## 5. Sink Method

### 5.1 How to define sink method

Notice:

1. The parameters of the sink point currently only support the following types, because we only focus on the propagation of String related type taint objects.
    - `String`
    - `char[]`
    - `char`
    - `String[]`
    - `StringReader`
    - `List<String>`
    - `Set<String>`


2. use method signatures in method call statements to define sink methods 

Suppose you have the following code
```java
interface Person{
    void work();
}

class Student implements Person{
    void work(){
        ...;
    }
}

public class Main{
    public static void main(...){
        Person p = new Student();
        p.work();
    }
}
```

The processing process of virtual method invocation `p.work();` is as follows:
1. Get the **method signature** of method invocation: `<Person: void work()>`
2. Get the class of the object pointed to by the BASE pointer `p`, which turn out to be `Student`.
3. Search for a method named `work` in `Student`, with input parameters and return value types of `void`, and finally find the **target method**`<Student: void work()>`

Suppose we want to define the `work()` method as a taint, then we should use the method signature `<Person: void work()>` of invocation to declare the sink method instead of the target method `<Student: void work()>`

This design has the following advantages:

1. No matter what type of object the BASE pointer `p` points to, as long as the method signatures match, the taint flow establish. In this way, the process of creating objects for the BASE pointer can be ignored, greatly reducing the complexity of creating the sink method.
2. we no longer care about the target method that is ultimately called, so that the definition of the target method and related classes can be ignored during analysis, greatly reducing the complexity of analysis.

For Example
```java
    public void T9() throws Exception {
        ScriptEngine scriptEngine = new ScriptEngineManager().getEngineByName("js");
        scriptEngine.eval(source()); 
    }
```

In this example, how to define the `eval()` method as a sink method?

- If you use the target method to declare the sink method, you need to consider the entire process of creating an object for the `scriptEgnine` pointer, and need to include `ScriptEngineManager` and other classes into the scope of analysis, otherwise it can't find the target method.
- If you use the method signature in invocation to declare the sink method, for example: `<javax.script.ScriptEngine: java.lang.Object eval(java.lang.String)>` in the interface class. We don’t need to care about the creation process of the `ScriptEgine` object at all. As long as the tainted object flows into the calling statement that satisfies the method signature, the tainted flow establishes.


### 5.2 Predefined sink method

The existing taint definitions are concentrated in CMDI and SQLI, distributed in three different files, each file represents a taint declaration method.

If you want to add new taint rules, it is recommended to add them to `LeakingSinkMethodArg` first.

#### `LeakingSinkMethodArg`

This file is located at `sink_rules/primitive_rules/LeakingSinkMethodArg.tsv`
Those rules are added according to owasp benchmark v1.1. 

One of the lines is defined as follows

- `cmdi` represents the label of the sink method, which can be customized and is just a prompt.
- `0` indicates that the `0`th parameter of the sink method is a taint parameter. If the taint object flows into this parameter, the taint flow is considered to be established.
- `<java.lang.Runtime: java.lang.Process exec(java.lang.String)>` is the signature of the sink method, which means method `java.lang.Process exec(java.lang.String)` of the `java.lang.Runtime` class method.

```tsv
cmdi	0	<java.lang.Runtime: java.lang.Process exec(java.lang.String)>
```

notice
- When declaring a sink method, the class where the method is located, the return value class, and the parameter class must all be full class paths.
- If there is no return value, declare it as `void`: `<java.lang.ProcessBuilder: void <init>(java.util.List)>`
- If there are multiple parameters, use `,` to separate them without spaces: `<java.lang.Runtime: java.lang.Process exec(java.lang.String,java.lang.String[])>`


#### `LeakingSinkMethodNameArg`

This file is located in `sink_rules/migrated_rules/LeakingSinkMethodNameArg.tsv`. It specifies the name of the sink method in the form of a regular expression and does not need to declare a parameter list.


One of the lines is defined as follows

- `S-3-16` is the label of the sink method
- `java.lang.Runtime` represents the declaration class where the sink method is located
- `exec` is a regular expression matching method names
- `2` indicates that the `2`th parameter of the method (index starts from 0) is a taint parameter

```tsv
S-3-16	java.lang.Runtime	exec	2
```

#### `LeakingSinkMethodNameVarArg`

This file is located in `sink_rules/migrated_rules/LeakingSinkMethodNameVarArg.tsv`, and the difference from `LeakingSinkMethodNameArg` is that the it declares a sink method with variable parameters.


One of the lines is defined as follows

- `S-3-24` is the label of the sink method
- `java.lang.ProcessBuilde` represents the declaration class where the sink method is located
- `command` represents the method name
- `0` means that the `0`th and followed parameters of the method are sink parameters.

```tsv
S-3-24	java.lang.ProcessBuilder	command	0
```

## 6. Owasp BenchMark

### 6.1 CMDI samples

- Test sample: Tested on 2708 command injection samples of `owasp BenchMark v1.1`
- The test environment is: 24-core CPU, 128G memory
- Resource consumption: actual peak memory usage 14G, facts generation time: 71s, taint stream analysis: 148s
- Accuracy = 84.80%, Recall = 100.00%

detailed results are as follows
```
Real samples: 1802
Fake samples: 906
Number of Analysis result: 2125
True Positive = 1802
True Negative = 583
False Positive = 323
False Negative = 0
True positive rate = 100.00%
False positive rate = 35.65%
Score = 64.35%
Precision = 84.80%
Recall = 100.00%
```

### 6.2 SQLI samples

- Test sample: Tested on 3529 SQL injection samples of `owasp BenchMark v1.1`
- The test environment is: 24-core CPU, 128G memory
- Resource consumption: actual peak memory usage 10G, facts generation time: 92s, taint stream analysis: 95s
- Accuracy = 84.42%, Recall = 100.00%


detailed results are as follows
```
Real samples: 2297
Fake samples: 1232
Number of Analysis result: 2721
True Positive = 2297
True Negative = 808
False Positive = 424
False Negative = 0
True positive rate = 100.00%
False positive rate = 34.42%
Score= 65.58%
Precision = 84.42%
Recall = 100.00%
```